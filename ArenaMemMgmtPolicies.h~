#ifndef ARENA_MEM_POLICY_H
#define ARENA_MEM_POLICY_H

#include <cstddef>
#include <memory>
#include "SmallVector.h"
#include <list>
#include <algorithm>
#include <functional>
#include <string>

const std::size_t SMALL_SIZE = 10;

template <typename T>
  struct ManageMem
  {
    
    struct PtrVals{
      T* buffer;
      T* begin;
      T* end;
      std::size_t size;
    };
       
    std::weak_ptr<T> currentVec;
    std::weak_ptr<T> priorVec;
    std::list<PtrVals> freeMem;
    std::string s = "going to manage the memory";

    bool can_use_memory(const PtrVals& x, std::size_t n)
      {	return (x.size >= n);}     

    //TUNING
    char* findMemory(std::size_t n){      
      auto it = freeMem.begin();
      for(; it!= freeMem.end(); it++){
	if(can_use_memory(*it, n)){
	  //	std::cout << "********found a match*********" << std::endl;
	break;
	}
      }
      if(it!=freeMem.end()){
	char* to_write;
	to_write = it->begin;
	if(it->size > n){
	  it->begin = it->begin + n;
	  it-> size = it->size - n;
	}
	else
	  {
	    freeMem.erase(it);
	  }
	return to_write;

	it = freeMem.begin();
	for(; it!= freeMem.end(); it++){
	}
      }
      else{
	return nullptr;     
      }
  }
    
    bool memory_is_smaller(const PtrVals& x, const PtrVals& y) const
      {	return x.size < y.size;}
    //WHY CAN'T I MAKE THIS A CONST CHAR*???

    void addMemory(char* p, std::size_t n){
      std::cout << "adding memory" << std::endl;
      PtrVals pVal;
      pVal.begin = p;
      pVal.size = n;
      
      std::cout << "adding memory: check if memory is smaller" << std::endl;
      auto it = freeMem.begin();
      for(; it!= freeMem.end(); it++){
	if(memory_is_smaller(*it, pVal)) break;
      }
      if(it != freeMem.end()) ++it;
      std::cout << "before try" << std::endl;
      try
	{
	  std::cout << "inside try" << std::endl;
	  std::list<PtrVals> *freeMemPtr;
	  freeMemPtr = &freeMem;
	  std::cout << "checking pointer" << std::endl;	  
	  if(!freeMemPtr) std::cout << "pointer not valid " << std::endl;
	  else std::cout << "pointer valid " << std::endl;

	  PtrVals *freeM;
	  freeM = &pVal;
	  std::cout << "checking INDIV pointer" << std::endl;	  
	  if(!freeM) std::cout << "pointer not valid " << std::endl;
	  else std::cout << "pointer valid " << std::endl;


	  freeMem.insert(it, pVal);
	}
      catch (int e)
	{
	}
    }
  };
    
template <typename T>
  struct NoManageMem
  {
    std::string s = "NOT going to manage the memory";
  };

#endif  // ARENA_MEM_POLICY_H
