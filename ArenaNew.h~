#ifndef ARENA_MEM_POLICY_H
#define ARENA_MEM_POLICY_H

#include <cstddef>
#include <memory>
#include "SmallVector.h"
#include <list>
#include <algorithm>
#include <functional>
#include <string>

const std::size_t SMALL_SIZE = 10;

template <typename T>
  struct ManageMem
  {
    
    struct PtrVals{
      T* buffer;
      T* begin;
      T* end;
      std::size_t size;
    };

    struct memory_is_better{
      bool operator()(const PtrVals& x, const PtrVals& y) const
      {
	return (x.buffer < y.buffer || ((x.buffer == y.buffer) && (x.size > y.size)));
      }     
    };
    

    
    std::weak_ptr<T> currentVec;
    std::weak_ptr<T> priorVec;
    std::list<PtrVals> freeMem;
    std::string s = "going to manage the memory";

    bool can_use_memory(const PtrVals& x, std::size_t n)
      {
	//TUNING should maybe require n be some min proportion of mem it receives? say at least 50%?
	return (x.size >= n);
      }     

    //TUNING
    char* findMemory(std::size_t n){      
      auto it = freeMem.begin();
      for(; it!= freeMem.end(); it++){
	if(can_use_memory(*it, n)){
	  //	std::cout << "********found a match*********" << std::endl;
	break;
	}
      }
      if(it!=freeMem.end()){
	char* to_write;
	to_write = it->begin;
	if(it->size > n){
	  it->begin = it->begin + n;
	  it-> size = it->size - n;
	}
	else
	  {
	    freeMem.erase(it);
	  }
	return to_write;

	it = freeMem.begin();
	for(; it!= freeMem.end(); it++){
	  //	  std::cout << "membership of list includes this address: " << (void *)(*it).begin << " of size " << (*it).size/4  << std::endl;
	}
      }
      else{
	it = freeMem.begin();
	for(; it!= freeMem.end(); it++){
	  //	  std::cout << "membership of list includes this address: " << (void *)(*it).begin << " of size " << (*it).size/4  << std::endl;
	}
	return nullptr;     
      }
      return nullptr;      
  }


    bool memory_is_smaller(const PtrVals& x, const PtrVals& y) const
      {
	return x.size < y.size;
      }
   

    //WHY CAN'T I MAKE THIS A CONST CHAR*???
    void addMemory(char* p, std::size_t n){

      
      PtrVals pVal;
      pVal.begin = p;
      pVal.size = n;
      
      auto it = freeMem.begin();
      for(; it!= freeMem.end(); it++){
	if(memory_is_smaller(*it, pVal)) break;
      }

      if(it != freeMem.end()) ++it;
      freeMem.insert(it, pVal);

      it = freeMem.begin();
      for(; it!= freeMem.end(); it++){
	//	std::cout << "membership of list includes this address: " << (void *)(*it).begin << " of size " << (*it).size/4  << std::endl;
      }

    }

  };
    
template <typename T>
  struct NoManageMem
  {
    std::string s = "NOT going to manage the memory";
  };

#endif  // ARENA_MEM_POLICY_H
